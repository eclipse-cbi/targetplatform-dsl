/**
 * generated by Xtext
 */
package fr.obeo.releng.targetplatform.validation;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Strings;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterables;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.LinkedHashMultiset;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimaps;
import com.google.common.collect.Multiset;
import com.google.common.collect.Sets;
import com.google.inject.Inject;
import fr.obeo.releng.targetplatform.Environment;
import fr.obeo.releng.targetplatform.IU;
import fr.obeo.releng.targetplatform.IncludeDeclaration;
import fr.obeo.releng.targetplatform.Location;
import fr.obeo.releng.targetplatform.Option;
import fr.obeo.releng.targetplatform.Options;
import fr.obeo.releng.targetplatform.TargetContent;
import fr.obeo.releng.targetplatform.TargetPlatform;
import fr.obeo.releng.targetplatform.TargetPlatformPackage;
import fr.obeo.releng.targetplatform.services.TargetPlatformGrammarAccess;
import fr.obeo.releng.targetplatform.util.LocationIndexBuilder;
import fr.obeo.releng.targetplatform.validation.AbstractTargetPlatformValidator;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Platform;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.equinox.p2.core.IProvisioningAgent;
import org.eclipse.equinox.p2.metadata.IInstallableUnit;
import org.eclipse.equinox.p2.metadata.VersionRange;
import org.eclipse.equinox.p2.query.IQuery;
import org.eclipse.equinox.p2.query.IQueryResult;
import org.eclipse.equinox.p2.query.QueryUtil;
import org.eclipse.equinox.p2.repository.metadata.IMetadataRepository;
import org.eclipse.equinox.p2.repository.metadata.IMetadataRepositoryManager;
import org.eclipse.jdt.launching.JavaRuntime;
import org.eclipse.jdt.launching.environments.IExecutionEnvironment;
import org.eclipse.jdt.launching.environments.IExecutionEnvironmentsManager;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.AbstractRule;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.BidiTreeIterable;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.impl.CompositeNode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class TargetPlatformValidator extends AbstractTargetPlatformValidator {
  @Inject
  private LocationIndexBuilder indexBuilder;
  
  @Inject
  private IProvisioningAgent provisioningAgent;
  
  @Inject
  private TargetPlatformGrammarAccess grammarAccess;
  
  public final static String CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED = "CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED";
  
  public final static String CHECK__OPTIONS_EQUALS_ALL_LOCATIONS = "CHECK__OPTIONS_EQUALS_ALL_LOCATIONS";
  
  public final static String CHECK__NO_OPTIONS_ON_LOCATIONS_IF_GLOBAL_OPTIONS = "CHECK__NO_OPTIONS_ON_LOCATIONS_IF_GLOBAL_OPTIONS";
  
  public final static String DEPRECATE__OPTIONS_ON_LOCATIONS = "DEPRECATE__OPTIONS_ON_LOCATIONS";
  
  public final static String DEPRECATE__STRINGS_ON_IU_VERSION = "DEPRECATE__STRINGS_ON_IU_VERSION";
  
  public final static String CHECK__LOCATION_CONFLICTUAL_ID = "CHECK__LOCATION_CONFLICTUAL_ID";
  
  public final static String CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID = "CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID";
  
  public final static String CHECK__CONFLICTUAL_ID__BETWEEN_INCLUDED_LOCATION = "CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID";
  
  public final static String CHECK__LOCATION_ID_UNIQNESS = "CHECK__LOCATION_ID_UNIQNESS";
  
  public final static String CHECK__INCLUDE_CYCLE = "CHECK__INCLUDE_CYCLE";
  
  public final static String CHECK__IU_IN_LOCATION = "CHECK__IU_IN_LOCATION";
  
  public final static String CHECK__LOCATION_URI = "CHECK__LOCATION_URI";
  
  public final static String CHECK__ENVIRONMENT_VALIDITY = "CHECK__ENVIRONMENT_VALIDITY";
  
  public final static String CHECK__ENVIRONMENT_UNICITY = "CHECK__ENVIRONMENT_UNICITY";
  
  public final static String CHECK__NO_DUPLICATE_ENVIRONMENT_OPTIONS = "CHECK__ENVIRONMENT_COHESION";
  
  public final static String CHECK__ESCAPE_CHAR_IU_ID = " CHECK__ESCAPE_CHAR_IU_ID";
  
  public final static String CHECK__VERSION_KEYWORDS = "CHECK__VERSION_KEYWORDS";
  
  public final static String CHECK__OPTIONS_UNICITY = "CHECK__OPTIONS_UNICITY";
  
  public final static String CHECK__NO_DUPLICATE_OPTIONS_OPTIONS = "CHECK__NO_DUPLICATE_OPTIONS_OPTIONS";
  
  public final static String CHECK__NO_DUPLICATED_IU = "CHECK__NO_DUPLICATED_IU";
  
  @Check
  public void checkAllEnvAndRequiredAreSelfExluding(final TargetPlatform targetPlatform) {
    EList<TargetContent> _contents = targetPlatform.getContents();
    Iterable<Options> _filter = Iterables.<Options>filter(_contents, Options.class);
    final Function1<Options, EList<Option>> _function = new Function1<Options, EList<Option>>() {
      public EList<Option> apply(final Options it) {
        return it.getOptions();
      }
    };
    Iterable<EList<Option>> _map = IterableExtensions.<Options, EList<Option>>map(_filter, _function);
    Iterable<Option> _flatten = Iterables.<Option>concat(_map);
    final Set<Option> allOptions = IterableExtensions.<Option>toSet(_flatten);
    boolean _and = false;
    boolean _contains = allOptions.contains(Option.INCLUDE_ALL_ENVIRONMENTS);
    if (!_contains) {
      _and = false;
    } else {
      boolean _contains_1 = allOptions.contains(Option.INCLUDE_REQUIRED);
      _and = _contains_1;
    }
    if (_and) {
      EList<TargetContent> _contents_1 = targetPlatform.getContents();
      Iterable<Options> _filter_1 = Iterables.<Options>filter(_contents_1, Options.class);
      final Consumer<Options> _function_1 = new Consumer<Options>() {
        public void accept(final Options it) {
          EList<Option> _options = it.getOptions();
          TargetPlatformValidator.this.doReportAllEnvAndRequiredAreSelfExluding(it, _options, TargetPlatformPackage.Literals.OPTIONS__OPTIONS);
        }
      };
      _filter_1.forEach(_function_1);
    }
  }
  
  @Check
  public void checkAllEnvAndRequiredAreSelfExluding(final Location location) {
    final EList<Option> options = location.getOptions();
    boolean _and = false;
    boolean _contains = options.contains(Option.INCLUDE_ALL_ENVIRONMENTS);
    if (!_contains) {
      _and = false;
    } else {
      boolean _contains_1 = options.contains(Option.INCLUDE_REQUIRED);
      _and = _contains_1;
    }
    if (_and) {
      this.doReportAllEnvAndRequiredAreSelfExluding(location, options, TargetPlatformPackage.Literals.LOCATION__OPTIONS);
    }
  }
  
  private void doReportAllEnvAndRequiredAreSelfExluding(final EObject optionOwner, final List<Option> options, final EStructuralFeature feature) {
    boolean _contains = options.contains(Option.INCLUDE_REQUIRED);
    if (_contains) {
      int _indexOf = options.indexOf(Option.INCLUDE_REQUIRED);
      this.error("All environments cannot be included along with required artifacts, you must choose one of the two options.", optionOwner, feature, _indexOf, TargetPlatformValidator.CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED);
    }
    boolean _contains_1 = options.contains(Option.INCLUDE_ALL_ENVIRONMENTS);
    if (_contains_1) {
      int _indexOf_1 = options.indexOf(Option.INCLUDE_ALL_ENVIRONMENTS);
      this.error("All environments cannot be included along with required artifacts, you must choose one of the two options.", optionOwner, feature, _indexOf_1, TargetPlatformValidator.CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED);
    }
  }
  
  @Check
  public void checkNoDuplicateOptions(final TargetPlatform targetPlatform) {
    EList<TargetContent> _contents = targetPlatform.getContents();
    Iterable<Options> _filter = Iterables.<Options>filter(_contents, Options.class);
    final Function1<Options, EList<Option>> _function = new Function1<Options, EList<Option>>() {
      public EList<Option> apply(final Options it) {
        return it.getOptions();
      }
    };
    Iterable<EList<Option>> _map = IterableExtensions.<Options, EList<Option>>map(_filter, _function);
    Iterable<Option> _flatten = Iterables.<Option>concat(_map);
    final HashMultiset<Option> allOptions = HashMultiset.<Option>create(_flatten);
    Set<Multiset.Entry<Option>> _entrySet = allOptions.entrySet();
    final Consumer<Multiset.Entry<Option>> _function_1 = new Consumer<Multiset.Entry<Option>>() {
      public void accept(final Multiset.Entry<Option> e) {
        int _count = e.getCount();
        boolean _greaterThan = (_count > 1);
        if (_greaterThan) {
          EList<TargetContent> _contents = targetPlatform.getContents();
          Iterable<Options> _filter = Iterables.<Options>filter(_contents, Options.class);
          final Consumer<Options> _function = new Consumer<Options>() {
            public void accept(final Options o) {
              for (int i = 0; (i < o.getOptions().size()); i++) {
                {
                  EList<Option> _options = o.getOptions();
                  final Option it = _options.get(i);
                  Option _element = e.getElement();
                  boolean _equals = Objects.equal(_element, it);
                  if (_equals) {
                    StringConcatenation _builder = new StringConcatenation();
                    _builder.append("Cannot define multiple option \'");
                    _builder.append(it, "");
                    _builder.append("\'.");
                    TargetPlatformValidator.this.error(_builder.toString(), o, TargetPlatformPackage.Literals.OPTIONS__OPTIONS, i, TargetPlatformValidator.CHECK__NO_DUPLICATE_OPTIONS_OPTIONS);
                  }
                }
              }
            }
          };
          _filter.forEach(_function);
        }
      }
    };
    _entrySet.forEach(_function_1);
  }
  
  @Check
  public void checkNoLocationOptionIfGlobalOptions(final Location location) {
    boolean _and = false;
    EList<Option> _options = location.getOptions();
    boolean _isEmpty = _options.isEmpty();
    boolean _not = (!_isEmpty);
    if (!_not) {
      _and = false;
    } else {
      TargetPlatform _targetPlatform = location.getTargetPlatform();
      EList<Option> _options_1 = _targetPlatform.getOptions();
      boolean _isEmpty_1 = _options_1.isEmpty();
      boolean _not_1 = (!_isEmpty_1);
      _and = _not_1;
    }
    if (_and) {
      final List<INode> nodes = NodeModelUtils.findNodesForFeature(location, TargetPlatformPackage.Literals.LOCATION__OPTIONS);
      INode _head = IterableExtensions.<INode>head(nodes);
      final INode withKeyword = ((CompositeNode) _head).getPreviousSibling();
      INode _last = IterableExtensions.<INode>last(nodes);
      final CompositeNode lastOption = ((CompositeNode) _last);
      int _offset = withKeyword.getOffset();
      int _endOffset = lastOption.getEndOffset();
      int _offset_1 = withKeyword.getOffset();
      int _minus = (_endOffset - _offset_1);
      this.acceptError("You cannot define options on location and on target platform.", location, _offset, _minus, TargetPlatformValidator.CHECK__NO_OPTIONS_ON_LOCATIONS_IF_GLOBAL_OPTIONS);
    }
  }
  
  @Check
  public void checkOptionsOnLocationAreIdentical(final TargetPlatform targetPlatform) {
    EList<Option> _options = targetPlatform.getOptions();
    boolean _isEmpty = _options.isEmpty();
    if (_isEmpty) {
      final EList<Location> listOptions = targetPlatform.getLocations();
      final Location first = IterableExtensions.<Location>head(listOptions);
      Iterable<Location> _tail = IterableExtensions.<Location>tail(listOptions);
      final Function1<Location, Boolean> _function = new Function1<Location, Boolean>() {
        public Boolean apply(final Location _) {
          EList<Option> _options = _.getOptions();
          Set<Option> _set = IterableExtensions.<Option>toSet(_options);
          EList<Option> _options_1 = first.getOptions();
          Set<Option> _set_1 = IterableExtensions.<Option>toSet(_options_1);
          Sets.SetView<Option> _symmetricDifference = Sets.<Option>symmetricDifference(_set, _set_1);
          boolean _isEmpty = _symmetricDifference.isEmpty();
          return Boolean.valueOf((!_isEmpty));
        }
      };
      final Iterable<Location> conflicts = IterableExtensions.<Location>filter(_tail, _function);
      boolean _isEmpty_1 = IterableExtensions.isEmpty(conflicts);
      boolean _not = (!_isEmpty_1);
      if (_not) {
        final Consumer<Location> _function_1 = new Consumer<Location>() {
          public void accept(final Location _) {
            final List<INode> nodes = NodeModelUtils.findNodesForFeature(_, TargetPlatformPackage.Literals.LOCATION__OPTIONS);
            boolean _isEmpty = nodes.isEmpty();
            boolean _not = (!_isEmpty);
            if (_not) {
              INode _head = IterableExtensions.<INode>head(nodes);
              final INode withKeyword = ((CompositeNode) _head).getPreviousSibling();
              INode _last = IterableExtensions.<INode>last(nodes);
              final CompositeNode lastOption = ((CompositeNode) _last);
              int _offset = withKeyword.getOffset();
              int _endOffset = lastOption.getEndOffset();
              int _offset_1 = withKeyword.getOffset();
              int _minus = (_endOffset - _offset_1);
              TargetPlatformValidator.this.acceptError("Options of all locations must be the same", _, _offset, _minus, TargetPlatformValidator.CHECK__OPTIONS_EQUALS_ALL_LOCATIONS);
            } else {
              final ICompositeNode node = NodeModelUtils.getNode(_);
              int _offset_2 = node.getOffset();
              int _length = node.getLength();
              TargetPlatformValidator.this.acceptError("Options of all locations must be the same", _, _offset_2, _length, TargetPlatformValidator.CHECK__OPTIONS_EQUALS_ALL_LOCATIONS);
            }
          }
        };
        listOptions.forEach(_function_1);
      }
    }
  }
  
  @Check
  public void deprecateOptionsOnLocation(final Location location) {
    final TargetPlatform targetPlatform = location.getTargetPlatform();
    boolean _and = false;
    EList<Option> _options = targetPlatform.getOptions();
    boolean _isEmpty = _options.isEmpty();
    if (!_isEmpty) {
      _and = false;
    } else {
      EList<Option> _options_1 = location.getOptions();
      boolean _isEmpty_1 = _options_1.isEmpty();
      boolean _not = (!_isEmpty_1);
      _and = _not;
    }
    if (_and) {
      final List<INode> nodes = NodeModelUtils.findNodesForFeature(location, TargetPlatformPackage.Literals.LOCATION__OPTIONS);
      INode _head = IterableExtensions.<INode>head(nodes);
      final INode withKeyword = ((CompositeNode) _head).getPreviousSibling();
      INode _last = IterableExtensions.<INode>last(nodes);
      final CompositeNode lastOption = ((CompositeNode) _last);
      int _offset = withKeyword.getOffset();
      int _endOffset = lastOption.getEndOffset();
      int _offset_1 = withKeyword.getOffset();
      int _minus = (_endOffset - _offset_1);
      this.acceptWarning("Options on location are deprecated. Define the option at the target level.", location, _offset, _minus, TargetPlatformValidator.DEPRECATE__OPTIONS_ON_LOCATIONS);
    }
  }
  
  @Check
  public void deprecateIUVersionRangeWihString(final IU iu) {
    String _version = iu.getVersion();
    boolean _notEquals = (!Objects.equal(_version, null));
    if (_notEquals) {
      final List<INode> nodes = NodeModelUtils.findNodesForFeature(iu, TargetPlatformPackage.Literals.IU__VERSION);
      INode _head = IterableExtensions.<INode>head(nodes);
      EObject _grammarElement = _head.getGrammarElement();
      AbstractRule _rule = ((RuleCall) _grammarElement).getRule();
      String _name = _rule.getName();
      boolean _equals = "STRING".equals(_name);
      if (_equals) {
        this.warning("Usage of strings is deprecated for version range. You should remove the quotes.", iu, 
          TargetPlatformPackage.Literals.IU__VERSION, 
          TargetPlatformValidator.DEPRECATE__STRINGS_ON_IU_VERSION);
      }
    }
  }
  
  @Check
  public void checkIDUniqueOnAllLocations(final TargetPlatform targetPlatform) {
    final ListMultimap<String, Location> locationsByURI = this.indexBuilder.getLocationIndex(targetPlatform);
    final Resource resource = targetPlatform.eResource();
    final LinkedHashMultimap<String, String> locationIDsByURI = LinkedHashMultimap.<String, String>create();
    Set<String> _keySet = locationsByURI.keySet();
    final Consumer<String> _function = new Consumer<String>() {
      public void accept(final String it) {
        List<Location> _get = locationsByURI.get(it);
        final Function1<Location, String> _function = new Function1<Location, String>() {
          public String apply(final Location it) {
            return it.getID();
          }
        };
        List<String> _map = ListExtensions.<Location, String>map(_get, _function);
        Set<String> _set = IterableExtensions.<String>toSet(_map);
        locationIDsByURI.putAll(it, _set);
      }
    };
    _keySet.forEach(_function);
    Map<String, Collection<String>> _asMap = locationIDsByURI.asMap();
    final Function2<String, Collection<String>, Boolean> _function_1 = new Function2<String, Collection<String>, Boolean>() {
      public Boolean apply(final String key, final Collection<String> value) {
        int _size = value.size();
        return Boolean.valueOf((_size <= 1));
      }
    };
    Map<String, Collection<String>> _filter = MapExtensions.<String, Collection<String>>filter(_asMap, _function_1);
    final Set<String> locationsURIWithoutConflictingID = _filter.keySet();
    final Function1<String, List<Location>> _function_2 = new Function1<String, List<Location>>() {
      public List<Location> apply(final String it) {
        return locationsByURI.get(it);
      }
    };
    Iterable<List<Location>> _map = IterableExtensions.<String, List<Location>>map(locationsURIWithoutConflictingID, _function_2);
    final Iterable<Location> locationsWithoutConflictingID = Iterables.<Location>concat(_map);
    final Function1<Location, Boolean> _function_3 = new Function1<Location, Boolean>() {
      public Boolean apply(final Location it) {
        String _iD = it.getID();
        return Boolean.valueOf((!Objects.equal(_iD, null)));
      }
    };
    Iterable<Location> _filter_1 = IterableExtensions.<Location>filter(locationsWithoutConflictingID, _function_3);
    final Function<Location, String> _function_4 = new Function<Location, String>() {
      public String apply(final Location it) {
        return it.getID();
      }
    };
    final ImmutableListMultimap<String, Location> locationsWithoutConflictingIDByID = Multimaps.<String, Location>index(_filter_1, _function_4);
    ImmutableMap<String, Collection<Location>> _asMap_1 = locationsWithoutConflictingIDByID.asMap();
    final Function2<String, Collection<Location>, Boolean> _function_5 = new Function2<String, Collection<Location>, Boolean>() {
      public Boolean apply(final String key, final Collection<Location> value) {
        final Function1<Location, String> _function = new Function1<Location, String>() {
          public String apply(final Location it) {
            return it.getUri();
          }
        };
        Iterable<String> _map = IterableExtensions.<Location, String>map(value, _function);
        Set<String> _set = IterableExtensions.<String>toSet(_map);
        int _size = _set.size();
        return Boolean.valueOf((_size > 1));
      }
    };
    Map<String, Collection<Location>> _filter_2 = MapExtensions.<String, Collection<Location>>filter(_asMap_1, _function_5);
    Collection<Collection<Location>> _values = _filter_2.values();
    final Iterable<Location> locationsWithDuplicateID = Iterables.<Location>concat(_values);
    final Consumer<Location> _function_6 = new Consumer<Location>() {
      public void accept(final Location location) {
        Resource _eResource = location.eResource();
        boolean _equals = Objects.equal(_eResource, resource);
        if (_equals) {
          TargetPlatformValidator.this.error("ID must be unique for each location", location, 
            TargetPlatformPackage.Literals.LOCATION__ID, 
            TargetPlatformValidator.CHECK__LOCATION_ID_UNIQNESS);
        } else {
          EList<IncludeDeclaration> _includes = targetPlatform.getIncludes();
          final Function1<IncludeDeclaration, Boolean> _function = new Function1<IncludeDeclaration, Boolean>() {
            public Boolean apply(final IncludeDeclaration it) {
              boolean _xblockexpression = false;
              {
                final TargetPlatform direct = TargetPlatformValidator.this.indexBuilder.getImportedTargetPlatform(resource, it);
                boolean _or = false;
                EList<Location> _locations = direct.getLocations();
                boolean _contains = _locations.contains(location);
                if (_contains) {
                  _or = true;
                } else {
                  LinkedList<TargetPlatform> _importedTargetPlatforms = TargetPlatformValidator.this.indexBuilder.getImportedTargetPlatforms(direct);
                  final Function1<TargetPlatform, EList<Location>> _function = new Function1<TargetPlatform, EList<Location>>() {
                    public EList<Location> apply(final TargetPlatform it) {
                      return it.getLocations();
                    }
                  };
                  List<EList<Location>> _map = ListExtensions.<TargetPlatform, EList<Location>>map(_importedTargetPlatforms, _function);
                  Iterable<Location> _flatten = Iterables.<Location>concat(_map);
                  Set<Location> _set = IterableExtensions.<Location>toSet(_flatten);
                  boolean _contains_1 = _set.contains(location);
                  _or = _contains_1;
                }
                _xblockexpression = _or;
              }
              return Boolean.valueOf(_xblockexpression);
            }
          };
          Iterable<IncludeDeclaration> _filter = IterableExtensions.<IncludeDeclaration>filter(_includes, _function);
          final Set<IncludeDeclaration> conflictualInclude = IterableExtensions.<IncludeDeclaration>toSet(_filter);
          final Consumer<IncludeDeclaration> _function_1 = new Consumer<IncludeDeclaration>() {
            public void accept(final IncludeDeclaration it) {
              StringConcatenation _builder = new StringConcatenation();
              _builder.append("ID \'");
              String _iD = location.getID();
              _builder.append(_iD, "");
              _builder.append("\' is duplicated in the included target platform");
              TargetPlatformValidator.this.error(_builder.toString(), it, 
                TargetPlatformPackage.Literals.INCLUDE_DECLARATION__IMPORT_URI, 
                TargetPlatformValidator.CHECK__LOCATION_ID_UNIQNESS);
            }
          };
          conflictualInclude.forEach(_function_1);
        }
      }
    };
    locationsWithDuplicateID.forEach(_function_6);
  }
  
  @Check
  public void checkImportCycle(final TargetPlatform targetPlatform) {
    final List<TargetPlatform> cycle = this.indexBuilder.checkIncludeCycle(targetPlatform);
    boolean _isEmpty = cycle.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      EList<IncludeDeclaration> _includes = targetPlatform.getIncludes();
      final Function1<IncludeDeclaration, Boolean> _function = new Function1<IncludeDeclaration, Boolean>() {
        public Boolean apply(final IncludeDeclaration it) {
          TargetPlatform _get = cycle.get(1);
          Resource _eResource = targetPlatform.eResource();
          TargetPlatform _importedTargetPlatform = TargetPlatformValidator.this.indexBuilder.getImportedTargetPlatform(_eResource, it);
          return Boolean.valueOf(_get.equals(_importedTargetPlatform));
        }
      };
      final IncludeDeclaration cyclingImport = IterableExtensions.<IncludeDeclaration>findFirst(_includes, _function);
      boolean _notEquals = (!Objects.equal(cyclingImport, null));
      if (_notEquals) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Cycle detected in the included target platforms. Cycle is \'");
        Iterable<TargetPlatform> _drop = IterableExtensions.<TargetPlatform>drop(cycle, 1);
        final Function1<TargetPlatform, URI> _function_1 = new Function1<TargetPlatform, URI>() {
          public URI apply(final TargetPlatform it) {
            Resource _eResource = it.eResource();
            return _eResource.getURI();
          }
        };
        Iterable<URI> _map = IterableExtensions.<TargetPlatform, URI>map(_drop, _function_1);
        String _join = IterableExtensions.join(_map, "\'\' -> \'");
        _builder.append(_join, "");
        _builder.append("\'.");
        this.error(_builder.toString(), cyclingImport, 
          TargetPlatformPackage.Literals.INCLUDE_DECLARATION__IMPORT_URI, 
          TargetPlatformValidator.CHECK__INCLUDE_CYCLE);
      }
    }
  }
  
  @Check
  public void checkSameIDForAllLocationWithSameURI(final TargetPlatform targetPlatform) {
    final ListMultimap<String, Location> locationsByURI = this.indexBuilder.getLocationIndex(targetPlatform);
    final Resource resource = targetPlatform.eResource();
    Set<String> _keySet = locationsByURI.keySet();
    for (final String locationURI : _keySet) {
      {
        List<Location> _get = locationsByURI.get(locationURI);
        final Function1<Location, Boolean> _function = new Function1<Location, Boolean>() {
          public Boolean apply(final Location it) {
            Resource _eResource = it.eResource();
            return Boolean.valueOf((!Objects.equal(_eResource, resource)));
          }
        };
        final Iterable<Location> externalLocations = IterableExtensions.<Location>filter(_get, _function);
        final Function1<Location, String> _function_1 = new Function1<Location, String>() {
          public String apply(final Location it) {
            String _iD = it.getID();
            return Strings.nullToEmpty(_iD);
          }
        };
        Iterable<String> _map = IterableExtensions.<Location, String>map(externalLocations, _function_1);
        final Set<String> externalIDs = IterableExtensions.<String>toSet(_map);
        List<Location> _get_1 = locationsByURI.get(locationURI);
        final Function1<Location, Boolean> _function_2 = new Function1<Location, Boolean>() {
          public Boolean apply(final Location it) {
            Resource _eResource = it.eResource();
            return Boolean.valueOf(Objects.equal(_eResource, resource));
          }
        };
        final Iterable<Location> internalLocations = IterableExtensions.<Location>filter(_get_1, _function_2);
        final Function1<Location, String> _function_3 = new Function1<Location, String>() {
          public String apply(final Location it) {
            String _iD = it.getID();
            return Strings.nullToEmpty(_iD);
          }
        };
        Iterable<String> _map_1 = IterableExtensions.<Location, String>map(internalLocations, _function_3);
        final Set<String> internalIDs = IterableExtensions.<String>toSet(_map_1);
        int _size = externalIDs.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          final Function1<Location, Boolean> _function_4 = new Function1<Location, Boolean>() {
            public Boolean apply(final Location it) {
              String _iD = it.getID();
              return Boolean.valueOf(externalIDs.contains(_iD));
            }
          };
          final Iterable<Location> externalLocationsWithConflictualID = IterableExtensions.<Location>filter(externalLocations, _function_4);
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The ID for location \'");
          _builder.append(locationURI, "");
          _builder.append("\' must be unique. Found \'");
          String _join = IterableExtensions.join(externalIDs, "\', \'");
          _builder.append(_join, "");
          _builder.append("\'  in \'");
          final Function1<Location, String> _function_5 = new Function1<Location, String>() {
            public String apply(final Location it) {
              Resource _eResource = it.eResource();
              URI _uRI = _eResource.getURI();
              return _uRI.toString();
            }
          };
          Iterable<String> _map_2 = IterableExtensions.<Location, String>map(externalLocationsWithConflictualID, _function_5);
          Set<String> _set = IterableExtensions.<String>toSet(_map_2);
          String _join_1 = IterableExtensions.join(_set, "\', \'");
          _builder.append(_join_1, "");
          _builder.append("\'.");
          final String msg = _builder.toString();
          final Function1<Location, Iterable<IncludeDeclaration>> _function_6 = new Function1<Location, Iterable<IncludeDeclaration>>() {
            public Iterable<IncludeDeclaration> apply(final Location location) {
              EList<IncludeDeclaration> _includes = targetPlatform.getIncludes();
              final Function1<IncludeDeclaration, Boolean> _function = new Function1<IncludeDeclaration, Boolean>() {
                public Boolean apply(final IncludeDeclaration it) {
                  boolean _xblockexpression = false;
                  {
                    final TargetPlatform direct = TargetPlatformValidator.this.indexBuilder.getImportedTargetPlatform(resource, it);
                    boolean _or = false;
                    EList<Location> _locations = direct.getLocations();
                    boolean _contains = _locations.contains(location);
                    if (_contains) {
                      _or = true;
                    } else {
                      LinkedList<TargetPlatform> _importedTargetPlatforms = TargetPlatformValidator.this.indexBuilder.getImportedTargetPlatforms(direct);
                      final Function1<TargetPlatform, EList<Location>> _function = new Function1<TargetPlatform, EList<Location>>() {
                        public EList<Location> apply(final TargetPlatform it) {
                          return it.getLocations();
                        }
                      };
                      List<EList<Location>> _map = ListExtensions.<TargetPlatform, EList<Location>>map(_importedTargetPlatforms, _function);
                      Iterable<Location> _flatten = Iterables.<Location>concat(_map);
                      Set<Location> _set = IterableExtensions.<Location>toSet(_flatten);
                      boolean _contains_1 = _set.contains(location);
                      _or = _contains_1;
                    }
                    _xblockexpression = _or;
                  }
                  return Boolean.valueOf(_xblockexpression);
                }
              };
              return IterableExtensions.<IncludeDeclaration>filter(_includes, _function);
            }
          };
          Iterable<Iterable<IncludeDeclaration>> _map_3 = IterableExtensions.<Location, Iterable<IncludeDeclaration>>map(externalLocationsWithConflictualID, _function_6);
          Iterable<IncludeDeclaration> _flatten = Iterables.<IncludeDeclaration>concat(_map_3);
          final Set<IncludeDeclaration> conflictualInclude = IterableExtensions.<IncludeDeclaration>toSet(_flatten);
          final Consumer<IncludeDeclaration> _function_7 = new Consumer<IncludeDeclaration>() {
            public void accept(final IncludeDeclaration it) {
              TargetPlatformValidator.this.error(msg, it, 
                TargetPlatformPackage.Literals.INCLUDE_DECLARATION__IMPORT_URI, 
                TargetPlatformValidator.CHECK__CONFLICTUAL_ID__BETWEEN_INCLUDED_LOCATION);
            }
          };
          conflictualInclude.forEach(_function_7);
        }
        int _size_1 = externalIDs.size();
        boolean _equals = (_size_1 == 1);
        if (_equals) {
          final Sets.SetView<String> diff = Sets.<String>symmetricDifference(externalIDs, internalIDs);
          boolean _isEmpty = diff.isEmpty();
          boolean _not = (!_isEmpty);
          if (_not) {
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("The ID for location \'");
            _builder_1.append(locationURI, "");
            _builder_1.append("\' must be unique across included target platforms and the current one. Found \'");
            String _head = IterableExtensions.<String>head(externalIDs);
            _builder_1.append(_head, "");
            _builder_1.append("\'  in \'");
            final Function1<Location, String> _function_8 = new Function1<Location, String>() {
              public String apply(final Location it) {
                Resource _eResource = it.eResource();
                URI _uRI = _eResource.getURI();
                return _uRI.toString();
              }
            };
            Iterable<String> _map_4 = IterableExtensions.<Location, String>map(externalLocations, _function_8);
            Set<String> _set_1 = IterableExtensions.<String>toSet(_map_4);
            String _join_2 = IterableExtensions.join(_set_1, "\', \'");
            _builder_1.append(_join_2, "");
            _builder_1.append("\'.");
            _builder_1.newLineIfNotEmpty();
            final String msg_1 = _builder_1.toString();
            final Function1<Location, Boolean> _function_9 = new Function1<Location, Boolean>() {
              public Boolean apply(final Location it) {
                String _iD = it.getID();
                String _nullToEmpty = Strings.nullToEmpty(_iD);
                boolean _contains = externalIDs.contains(_nullToEmpty);
                return Boolean.valueOf((!_contains));
              }
            };
            Iterable<Location> _filter = IterableExtensions.<Location>filter(internalLocations, _function_9);
            final Consumer<Location> _function_10 = new Consumer<Location>() {
              public void accept(final Location it) {
                String _head = IterableExtensions.<String>head(externalIDs);
                Location _head_1 = IterableExtensions.<Location>head(externalLocations);
                String _uri = _head_1.getUri();
                TargetPlatformValidator.this.error(msg_1, it, TargetPlatformPackage.Literals.LOCATION__ID, TargetPlatformValidator.CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID, _head, _uri);
              }
            };
            _filter.forEach(_function_10);
          }
        }
        boolean _and = false;
        int _size_2 = externalIDs.size();
        boolean _lessThan = (_size_2 < 1);
        if (!_lessThan) {
          _and = false;
        } else {
          int _size_3 = internalIDs.size();
          boolean _greaterThan_1 = (_size_3 > 1);
          _and = _greaterThan_1;
        }
        if (_and) {
          StringConcatenation _builder_2 = new StringConcatenation();
          _builder_2.append("The ID for location \'");
          _builder_2.append(locationURI, "");
          _builder_2.append("\' must be unique. Found \'");
          String _join_3 = IterableExtensions.join(internalIDs, "\', \'");
          _builder_2.append(_join_3, "");
          _builder_2.append("\'.");
          final String msg_2 = _builder_2.toString();
          final Consumer<Location> _function_11 = new Consumer<Location>() {
            public void accept(final Location it) {
              TargetPlatformValidator.this.error(msg_2, it, TargetPlatformPackage.Literals.LOCATION__ID, TargetPlatformValidator.CHECK__LOCATION_CONFLICTUAL_ID);
            }
          };
          internalLocations.forEach(_function_11);
        }
      }
    }
  }
  
  @Check(value = CheckType.EXPENSIVE)
  public IMetadataRepository checkLocationURI(final Location location) {
    IMetadataRepository _xblockexpression = null;
    {
      IProgressMonitor _xifexpression = null;
      boolean _and = false;
      Map<Object, Object> _context = this.getContext();
      boolean _notEquals = (!Objects.equal(_context, null));
      if (!_notEquals) {
        _and = false;
      } else {
        Map<Object, Object> _context_1 = this.getContext();
        Object _get = _context_1.get(IProgressMonitor.class);
        boolean _notEquals_1 = (!Objects.equal(_get, null));
        _and = _notEquals_1;
      }
      if (_and) {
        Map<Object, Object> _context_2 = this.getContext();
        Object _get_1 = _context_2.get(IProgressMonitor.class);
        _xifexpression = ((IProgressMonitor) _get_1);
      } else {
        _xifexpression = new NullProgressMonitor();
      }
      final IProgressMonitor monitor = _xifexpression;
      IMetadataRepository _xifexpression_1 = null;
      String _uri = location.getUri();
      boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_uri);
      boolean _not = (!_isNullOrEmpty);
      if (_not) {
        IMetadataRepository _xblockexpression_1 = null;
        {
          Object _service = this.provisioningAgent.getService(IMetadataRepositoryManager.SERVICE_NAME);
          final IMetadataRepositoryManager repositoryManager = ((IMetadataRepositoryManager) _service);
          IMetadataRepository _xtrycatchfinallyexpression = null;
          try {
            String _uri_1 = location.getUri();
            java.net.URI _uRI = new java.net.URI(_uri_1);
            _xtrycatchfinallyexpression = repositoryManager.loadRepository(_uRI, monitor);
          } catch (final Throwable _t) {
            if (_t instanceof Exception) {
              final Exception e = (Exception)_t;
              String _message = e.getMessage();
              boolean _isNullOrEmpty_1 = StringExtensions.isNullOrEmpty(_message);
              if (_isNullOrEmpty_1) {
                StringConcatenation _builder = new StringConcatenation();
                _builder.append("Error occured while loading p2 repository at \'");
                String _uri_2 = location.getUri();
                _builder.append(_uri_2, "");
                _builder.append("\'.");
                this.error(_builder.toString(), location, TargetPlatformPackage.Literals.LOCATION__URI, TargetPlatformValidator.CHECK__LOCATION_URI);
              } else {
                String _message_1 = e.getMessage();
                this.error(_message_1, location, TargetPlatformPackage.Literals.LOCATION__URI, TargetPlatformValidator.CHECK__LOCATION_URI);
              }
            } else {
              throw Exceptions.sneakyThrow(_t);
            }
          }
          _xblockexpression_1 = _xtrycatchfinallyexpression;
        }
        _xifexpression_1 = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression_1;
    }
    return _xblockexpression;
  }
  
  @Check(value = CheckType.EXPENSIVE)
  public Object checkIUIDAndRangeInRepository(final IU iu) {
    Object _xblockexpression = null;
    {
      Object _service = this.provisioningAgent.getService(IMetadataRepositoryManager.SERVICE_NAME);
      final IMetadataRepositoryManager repositoryManager = ((IMetadataRepositoryManager) _service);
      Object _xtrycatchfinallyexpression = null;
      try {
        Location _location = iu.getLocation();
        String _uri = _location.getUri();
        java.net.URI _uRI = new java.net.URI(_uri);
        NullProgressMonitor _nullProgressMonitor = new NullProgressMonitor();
        final IMetadataRepository metadataRepository = repositoryManager.loadRepository(_uRI, _nullProgressMonitor);
        String _iD = iu.getID();
        IQuery<IInstallableUnit> _createIUQuery = QueryUtil.createIUQuery(_iD);
        NullProgressMonitor _nullProgressMonitor_1 = new NullProgressMonitor();
        IQueryResult<IInstallableUnit> _query = metadataRepository.query(_createIUQuery, _nullProgressMonitor_1);
        final Set<IInstallableUnit> idResults = _query.toUnmodifiableSet();
        boolean _isEmpty = idResults.isEmpty();
        if (_isEmpty) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("No installable unit with ID \'");
          String _iD_1 = iu.getID();
          _builder.append(_iD_1, "");
          _builder.append("\' can be found in \'");
          Location _location_1 = iu.getLocation();
          String _uri_1 = _location_1.getUri();
          _builder.append(_uri_1, "");
          _builder.append("\'.");
          this.error(_builder.toString(), iu, TargetPlatformPackage.Literals.IU__ID, TargetPlatformValidator.CHECK__IU_IN_LOCATION);
        } else {
          boolean _and = false;
          String _version = iu.getVersion();
          boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_version);
          boolean _not = (!_isNullOrEmpty);
          if (!_not) {
            _and = false;
          } else {
            String _version_1 = iu.getVersion();
            boolean _equals = "lazy".equals(_version_1);
            boolean _not_1 = (!_equals);
            _and = _not_1;
          }
          if (_and) {
            String _iD_2 = iu.getID();
            String _version_2 = iu.getVersion();
            VersionRange _versionRange = new VersionRange(_version_2);
            IQuery<IInstallableUnit> _createQuery = QueryUtil.createQuery("latest(x | x.id == $0 && x.version ~= $1)", _iD_2, _versionRange);
            NullProgressMonitor _nullProgressMonitor_2 = new NullProgressMonitor();
            final IQueryResult<IInstallableUnit> versionResult = metadataRepository.query(_createQuery, _nullProgressMonitor_2);
            boolean _isEmpty_1 = versionResult.isEmpty();
            if (_isEmpty_1) {
              StringConcatenation _builder_1 = new StringConcatenation();
              _builder_1.append("No installable unit with ID \'");
              String _iD_3 = iu.getID();
              _builder_1.append(_iD_3, "");
              _builder_1.append("\' can be found with range constraint \'");
              String _version_3 = iu.getVersion();
              _builder_1.append(_version_3, "");
              _builder_1.append("\'.");
              this.error(_builder_1.toString(), iu, TargetPlatformPackage.Literals.IU__VERSION, TargetPlatformValidator.CHECK__IU_IN_LOCATION);
            }
          }
        }
      } catch (final Throwable _t) {
        if (_t instanceof Exception) {
          final Exception e = (Exception)_t;
          _xtrycatchfinallyexpression = null;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      _xblockexpression = _xtrycatchfinallyexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkEnvironment(final Environment env) {
    EList<String> _env = env.getEnv();
    final ArrayList<String> dupEnv = Lists.<String>newArrayList(_env);
    final Iterator<String> dupEnvIt = dupEnv.iterator();
    String[] _knownOSValues = Platform.knownOSValues();
    final Function1<String, String> _function = new Function1<String, String>() {
      public String apply(final String it) {
        return it.toUpperCase();
      }
    };
    final List<String> knownOSUpperValues = ListExtensions.<String, String>map(((List<String>)Conversions.doWrapArray(_knownOSValues)), _function);
    String[] _knownWSValues = Platform.knownWSValues();
    final Function1<String, String> _function_1 = new Function1<String, String>() {
      public String apply(final String it) {
        return it.toUpperCase();
      }
    };
    final List<String> knownWSUpperValues = ListExtensions.<String, String>map(((List<String>)Conversions.doWrapArray(_knownWSValues)), _function_1);
    String[] _knownOSArchValues = Platform.knownOSArchValues();
    final Function1<String, String> _function_2 = new Function1<String, String>() {
      public String apply(final String it) {
        return it.toUpperCase();
      }
    };
    final List<String> knownArchUpperValues = ListExtensions.<String, String>map(((List<String>)Conversions.doWrapArray(_knownOSArchValues)), _function_2);
    Locale[] _availableLocales = Locale.getAvailableLocales();
    final Function1<Locale, String> _function_3 = new Function1<Locale, String>() {
      public String apply(final Locale it) {
        return it.toString();
      }
    };
    List<String> _map = ListExtensions.<Locale, String>map(((List<Locale>)Conversions.doWrapArray(_availableLocales)), _function_3);
    final Function1<String, String> _function_4 = new Function1<String, String>() {
      public String apply(final String it) {
        return it.toUpperCase();
      }
    };
    final List<String> knownLocale = ListExtensions.<String, String>map(_map, _function_4);
    IExecutionEnvironmentsManager _executionEnvironmentsManager = JavaRuntime.getExecutionEnvironmentsManager();
    IExecutionEnvironment[] _executionEnvironments = _executionEnvironmentsManager.getExecutionEnvironments();
    final Function1<IExecutionEnvironment, String> _function_5 = new Function1<IExecutionEnvironment, String>() {
      public String apply(final IExecutionEnvironment it) {
        String _id = it.getId();
        return _id.toUpperCase();
      }
    };
    final List<String> knownEE = ListExtensions.<IExecutionEnvironment, String>map(((List<IExecutionEnvironment>)Conversions.doWrapArray(_executionEnvironments)), _function_5);
    while (dupEnvIt.hasNext()) {
      {
        String _next = dupEnvIt.next();
        final String envValue = _next.toUpperCase();
        boolean _or = false;
        boolean _or_1 = false;
        boolean _or_2 = false;
        boolean _or_3 = false;
        boolean _contains = knownOSUpperValues.contains(envValue);
        if (_contains) {
          _or_3 = true;
        } else {
          boolean _contains_1 = knownWSUpperValues.contains(envValue);
          _or_3 = _contains_1;
        }
        if (_or_3) {
          _or_2 = true;
        } else {
          boolean _contains_2 = knownArchUpperValues.contains(envValue);
          _or_2 = _contains_2;
        }
        if (_or_2) {
          _or_1 = true;
        } else {
          boolean _contains_3 = knownLocale.contains(envValue);
          _or_1 = _contains_3;
        }
        if (_or_1) {
          _or = true;
        } else {
          boolean _contains_4 = knownEE.contains(envValue);
          _or = _contains_4;
        }
        if (_or) {
          dupEnvIt.remove();
        }
      }
    }
    for (final String errorEnv : dupEnv) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\'");
      _builder.append(errorEnv, "");
      _builder.append("\' is not a valid environment specification value.");
      EList<String> _env_1 = env.getEnv();
      int _indexOf = _env_1.indexOf(errorEnv);
      this.error(_builder.toString(), env, 
        TargetPlatformPackage.Literals.ENVIRONMENT__ENV, _indexOf, TargetPlatformValidator.CHECK__ENVIRONMENT_VALIDITY);
    }
  }
  
  @Check
  public void checkOneEnvironment(final TargetPlatform tp) {
    EList<TargetContent> _contents = tp.getContents();
    Iterable<Environment> _filter = Iterables.<Environment>filter(_contents, Environment.class);
    final List<Environment> envList = IterableExtensions.<Environment>toList(_filter);
    int _size = envList.size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      Iterable<Environment> _tail = IterableExtensions.<Environment>tail(envList);
      final Consumer<Environment> _function = new Consumer<Environment>() {
        public void accept(final Environment it) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("Environment definition should not be split across the file.");
          EList<TargetContent> _contents = tp.getContents();
          int _indexOf = _contents.indexOf(it);
          TargetPlatformValidator.this.warning(_builder.toString(), tp, TargetPlatformPackage.Literals.TARGET_PLATFORM__CONTENTS, _indexOf, TargetPlatformValidator.CHECK__ENVIRONMENT_UNICITY);
        }
      };
      _tail.forEach(_function);
    }
  }
  
  @Check
  public void checkOneOptions(final TargetPlatform tp) {
    EList<TargetContent> _contents = tp.getContents();
    Iterable<Options> _filter = Iterables.<Options>filter(_contents, Options.class);
    final List<Options> envList = IterableExtensions.<Options>toList(_filter);
    int _size = envList.size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      Iterable<Options> _tail = IterableExtensions.<Options>tail(envList);
      final Consumer<Options> _function = new Consumer<Options>() {
        public void accept(final Options it) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("Options definition should not be split across the file.");
          EList<TargetContent> _contents = tp.getContents();
          int _indexOf = _contents.indexOf(it);
          TargetPlatformValidator.this.warning(_builder.toString(), tp, TargetPlatformPackage.Literals.TARGET_PLATFORM__CONTENTS, _indexOf, TargetPlatformValidator.CHECK__OPTIONS_UNICITY);
        }
      };
      _tail.forEach(_function);
    }
  }
  
  @Check
  public void checkNoDuplicateEnvironmentOptions(final TargetPlatform tp) {
    final Environment tpEnv = tp.getEnvironment();
    String[] _knownOSValues = Platform.knownOSValues();
    final Function1<String, String> _function = new Function1<String, String>() {
      public String apply(final String it) {
        return it.toUpperCase();
      }
    };
    final List<String> knownOSUpperValues = ListExtensions.<String, String>map(((List<String>)Conversions.doWrapArray(_knownOSValues)), _function);
    String[] _knownWSValues = Platform.knownWSValues();
    final Function1<String, String> _function_1 = new Function1<String, String>() {
      public String apply(final String it) {
        return it.toUpperCase();
      }
    };
    final List<String> knownWSUpperValues = ListExtensions.<String, String>map(((List<String>)Conversions.doWrapArray(_knownWSValues)), _function_1);
    String[] _knownOSArchValues = Platform.knownOSArchValues();
    final Function1<String, String> _function_2 = new Function1<String, String>() {
      public String apply(final String it) {
        return it.toUpperCase();
      }
    };
    final List<String> knownArchUpperValues = ListExtensions.<String, String>map(((List<String>)Conversions.doWrapArray(_knownOSArchValues)), _function_2);
    Locale[] _availableLocales = Locale.getAvailableLocales();
    final Function1<Locale, String> _function_3 = new Function1<Locale, String>() {
      public String apply(final Locale it) {
        String _string = it.toString();
        return _string.toUpperCase();
      }
    };
    final List<String> knownLocale = ListExtensions.<Locale, String>map(((List<Locale>)Conversions.doWrapArray(_availableLocales)), _function_3);
    IExecutionEnvironmentsManager _executionEnvironmentsManager = JavaRuntime.getExecutionEnvironmentsManager();
    IExecutionEnvironment[] _executionEnvironments = _executionEnvironmentsManager.getExecutionEnvironments();
    final Function1<IExecutionEnvironment, String> _function_4 = new Function1<IExecutionEnvironment, String>() {
      public String apply(final IExecutionEnvironment it) {
        String _id = it.getId();
        return _id.toUpperCase();
      }
    };
    final List<String> knownEE = ListExtensions.<IExecutionEnvironment, String>map(((List<IExecutionEnvironment>)Conversions.doWrapArray(_executionEnvironments)), _function_4);
    EList<TargetContent> _contents = tp.getContents();
    Iterable<Environment> _filter = Iterables.<Environment>filter(_contents, Environment.class);
    final Function1<Environment, EList<String>> _function_5 = new Function1<Environment, EList<String>>() {
      public EList<String> apply(final Environment it) {
        return it.getEnv();
      }
    };
    Iterable<EList<String>> _map = IterableExtensions.<Environment, EList<String>>map(_filter, _function_5);
    Iterable<String> _flatten = Iterables.<String>concat(_map);
    final Function1<String, Boolean> _function_6 = new Function1<String, Boolean>() {
      public Boolean apply(final String it) {
        boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(it);
        return Boolean.valueOf((!_isNullOrEmpty));
      }
    };
    Iterable<String> _filter_1 = IterableExtensions.<String>filter(_flatten, _function_6);
    final List<String> envList = IterableExtensions.<String>toList(_filter_1);
    final Function1<String, Boolean> _function_7 = new Function1<String, Boolean>() {
      public Boolean apply(final String it) {
        String _upperCase = it.toUpperCase();
        String _windowingSystem = tpEnv.getWindowingSystem();
        String _upperCase_1 = null;
        if (_windowingSystem!=null) {
          _upperCase_1=_windowingSystem.toUpperCase();
        }
        boolean _equals = _upperCase.equals(_upperCase_1);
        return Boolean.valueOf((!_equals));
      }
    };
    Iterable<String> _filter_2 = IterableExtensions.<String>filter(envList, _function_7);
    final Function1<String, Boolean> _function_8 = new Function1<String, Boolean>() {
      public Boolean apply(final String it) {
        String _upperCase = it.toUpperCase();
        return Boolean.valueOf(knownOSUpperValues.contains(_upperCase));
      }
    };
    Iterable<String> _filter_3 = IterableExtensions.<String>filter(_filter_2, _function_8);
    final LinkedHashMultiset<String> allOS = LinkedHashMultiset.<String>create(_filter_3);
    final Function1<String, Boolean> _function_9 = new Function1<String, Boolean>() {
      public Boolean apply(final String it) {
        String _upperCase = it.toUpperCase();
        String _operatingSystem = tpEnv.getOperatingSystem();
        String _upperCase_1 = null;
        if (_operatingSystem!=null) {
          _upperCase_1=_operatingSystem.toUpperCase();
        }
        boolean _equals = _upperCase.equals(_upperCase_1);
        return Boolean.valueOf((!_equals));
      }
    };
    Iterable<String> _filter_4 = IterableExtensions.<String>filter(envList, _function_9);
    final Function1<String, Boolean> _function_10 = new Function1<String, Boolean>() {
      public Boolean apply(final String it) {
        String _upperCase = it.toUpperCase();
        return Boolean.valueOf(knownWSUpperValues.contains(_upperCase));
      }
    };
    Iterable<String> _filter_5 = IterableExtensions.<String>filter(_filter_4, _function_10);
    final LinkedHashMultiset<String> allWS = LinkedHashMultiset.<String>create(_filter_5);
    final Function1<String, Boolean> _function_11 = new Function1<String, Boolean>() {
      public Boolean apply(final String it) {
        String _upperCase = it.toUpperCase();
        return Boolean.valueOf(knownArchUpperValues.contains(_upperCase));
      }
    };
    Iterable<String> _filter_6 = IterableExtensions.<String>filter(envList, _function_11);
    final LinkedHashMultiset<String> allArch = LinkedHashMultiset.<String>create(_filter_6);
    final Function1<String, Boolean> _function_12 = new Function1<String, Boolean>() {
      public Boolean apply(final String it) {
        String _upperCase = it.toUpperCase();
        return Boolean.valueOf(knownLocale.contains(_upperCase));
      }
    };
    Iterable<String> _filter_7 = IterableExtensions.<String>filter(envList, _function_12);
    final LinkedHashMultiset<String> allLocale = LinkedHashMultiset.<String>create(_filter_7);
    final Function1<String, Boolean> _function_13 = new Function1<String, Boolean>() {
      public Boolean apply(final String it) {
        String _upperCase = it.toUpperCase();
        return Boolean.valueOf(knownEE.contains(_upperCase));
      }
    };
    Iterable<String> _filter_8 = IterableExtensions.<String>filter(envList, _function_13);
    final LinkedHashMultiset<String> allEE = LinkedHashMultiset.<String>create(_filter_8);
    this.reportDuplicatedEnvironmentOptions(tp, allOS, "Cannot define multiple operating systems.");
    this.reportDuplicatedEnvironmentOptions(tp, allWS, "Cannot define multiple windowing systems.");
    this.reportDuplicatedEnvironmentOptions(tp, allArch, "Cannot define multiple processor architectures.");
    this.reportDuplicatedEnvironmentOptions(tp, allLocale, "Cannot define multiple localizations.");
    this.reportDuplicatedEnvironmentOptions(tp, allEE, "Cannot define multiple execution environments.");
  }
  
  private void reportDuplicatedEnvironmentOptions(final TargetPlatform targetPlatform, final Multiset<String> valuesInFile, final String msg) {
    boolean _or = false;
    int _size = valuesInFile.size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      _or = true;
    } else {
      Set<Multiset.Entry<String>> _entrySet = valuesInFile.entrySet();
      final Function1<Multiset.Entry<String>, Boolean> _function = new Function1<Multiset.Entry<String>, Boolean>() {
        public Boolean apply(final Multiset.Entry<String> it) {
          int _count = it.getCount();
          return Boolean.valueOf((_count > 1));
        }
      };
      boolean _exists = IterableExtensions.<Multiset.Entry<String>>exists(_entrySet, _function);
      _or = _exists;
    }
    if (_or) {
      Set<String> _elementSet = valuesInFile.elementSet();
      final Consumer<String> _function_1 = new Consumer<String>() {
        public void accept(final String e) {
          EList<TargetContent> _contents = targetPlatform.getContents();
          Iterable<Environment> _filter = Iterables.<Environment>filter(_contents, Environment.class);
          final Consumer<Environment> _function = new Consumer<Environment>() {
            public void accept(final Environment env) {
              for (int i = 0; (i < env.getEnv().size()); i++) {
                {
                  EList<String> _env = env.getEnv();
                  final String it = _env.get(i);
                  boolean _equals = e.equals(it);
                  if (_equals) {
                    TargetPlatformValidator.this.error(msg, env, TargetPlatformPackage.Literals.ENVIRONMENT__ENV, i, TargetPlatformValidator.CHECK__NO_DUPLICATE_ENVIRONMENT_OPTIONS);
                  }
                }
              }
            }
          };
          _filter.forEach(_function);
        }
      };
      _elementSet.forEach(_function_1);
    }
  }
  
  @Check
  public void checkNoEscapeCharacterInIUID(final IU iu) {
    final ICompositeNode node = NodeModelUtils.getNode(iu);
    BidiTreeIterable<INode> _asTreeIterable = node.getAsTreeIterable();
    final Function1<INode, Boolean> _function = new Function1<INode, Boolean>() {
      public Boolean apply(final INode it) {
        EObject _grammarElement = it.getGrammarElement();
        TargetPlatformGrammarAccess.IUElements _iUAccess = TargetPlatformValidator.this.grammarAccess.getIUAccess();
        RuleCall _iDIDTerminalRuleCall_0_0 = _iUAccess.getIDIDTerminalRuleCall_0_0();
        return Boolean.valueOf(Objects.equal(_grammarElement, _iDIDTerminalRuleCall_0_0));
      }
    };
    final INode idRule = IterableExtensions.<INode>findFirst(_asTreeIterable, _function);
    String _xifexpression = null;
    boolean _and = false;
    String _text = idRule.getText();
    boolean _startsWith = _text.startsWith("^");
    if (!_startsWith) {
      _and = false;
    } else {
      String _text_1 = idRule.getText();
      boolean _contains = _text_1.contains(".");
      boolean _not = (!_contains);
      _and = _not;
    }
    if (_and) {
      String _text_2 = idRule.getText();
      _xifexpression = _text_2.substring(1);
    } else {
      _xifexpression = idRule.getText();
    }
    final String id = _xifexpression;
    boolean _contains_1 = id.contains("^");
    if (_contains_1) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Usage of escape character \'^\' in the ID of IUs is not required anymore and has been deprecated.");
      this.warning(_builder.toString(), iu, TargetPlatformPackage.Literals.IU__ID, TargetPlatformValidator.CHECK__ESCAPE_CHAR_IU_ID);
    }
  }
  
  @Check
  public void checkVersionKeywords(final IU iu) {
    final ICompositeNode node = NodeModelUtils.getNode(iu);
    BidiTreeIterable<INode> _asTreeIterable = node.getAsTreeIterable();
    final Function1<INode, Boolean> _function = new Function1<INode, Boolean>() {
      public Boolean apply(final INode it) {
        EObject _grammarElement = it.getGrammarElement();
        TargetPlatformGrammarAccess.IUElements _iUAccess = TargetPlatformValidator.this.grammarAccess.getIUAccess();
        Keyword _semicolonKeyword_1_0_0 = _iUAccess.getSemicolonKeyword_1_0_0();
        return Boolean.valueOf(Objects.equal(_grammarElement, _semicolonKeyword_1_0_0));
      }
    };
    final INode semicolonKeywordRule = IterableExtensions.<INode>findFirst(_asTreeIterable, _function);
    BidiTreeIterable<INode> _asTreeIterable_1 = node.getAsTreeIterable();
    final Function1<INode, Boolean> _function_1 = new Function1<INode, Boolean>() {
      public Boolean apply(final INode it) {
        EObject _grammarElement = it.getGrammarElement();
        TargetPlatformGrammarAccess.IUElements _iUAccess = TargetPlatformValidator.this.grammarAccess.getIUAccess();
        Keyword _equalsSignKeyword_1_0_2 = _iUAccess.getEqualsSignKeyword_1_0_2();
        return Boolean.valueOf(Objects.equal(_grammarElement, _equalsSignKeyword_1_0_2));
      }
    };
    final INode equalSignKeywordRule = IterableExtensions.<INode>findFirst(_asTreeIterable_1, _function_1);
    boolean _notEquals = (!Objects.equal(semicolonKeywordRule, null));
    if (_notEquals) {
      int _offset = semicolonKeywordRule.getOffset();
      int _endOffset = equalSignKeywordRule.getEndOffset();
      int _offset_1 = semicolonKeywordRule.getOffset();
      int _minus = (_endOffset - _offset_1);
      this.acceptWarning("Usage of keywords \';version=\' are not required anymore and has been deprecated.", iu, _offset, _minus, TargetPlatformValidator.CHECK__VERSION_KEYWORDS);
    }
  }
  
  @Check
  public void checkNoDuplicatedIU(final TargetPlatform targetPlatform) {
    final LinkedList<TargetPlatform> importedTPs = this.indexBuilder.getImportedTargetPlatforms(targetPlatform);
    final Function1<TargetPlatform, EList<Location>> _function = new Function1<TargetPlatform, EList<Location>>() {
      public EList<Location> apply(final TargetPlatform it) {
        return it.getLocations();
      }
    };
    List<EList<Location>> _map = ListExtensions.<TargetPlatform, EList<Location>>map(importedTPs, _function);
    Iterable<Location> _flatten = Iterables.<Location>concat(_map);
    final Function1<Location, EList<IU>> _function_1 = new Function1<Location, EList<IU>>() {
      public EList<IU> apply(final Location it) {
        return it.getIus();
      }
    };
    Iterable<EList<IU>> _map_1 = IterableExtensions.<Location, EList<IU>>map(_flatten, _function_1);
    Iterable<IU> _flatten_1 = Iterables.<IU>concat(_map_1);
    final Set<IU> importedIUs = IterableExtensions.<IU>toSet(_flatten_1);
    EList<Location> _locations = targetPlatform.getLocations();
    final Function1<Location, EList<IU>> _function_2 = new Function1<Location, EList<IU>>() {
      public EList<IU> apply(final Location it) {
        return it.getIus();
      }
    };
    List<EList<IU>> _map_2 = ListExtensions.<Location, EList<IU>>map(_locations, _function_2);
    Iterable<IU> _flatten_2 = Iterables.<IU>concat(_map_2);
    final Function1<IU, String> _function_3 = new Function1<IU, String>() {
      public String apply(final IU it) {
        return it.getID();
      }
    };
    Iterable<String> _map_3 = IterableExtensions.<IU, String>map(_flatten_2, _function_3);
    final HashMultiset<String> localIUsID = HashMultiset.<String>create(_map_3);
    final Function1<IU, String> _function_4 = new Function1<IU, String>() {
      public String apply(final IU it) {
        return it.getID();
      }
    };
    Iterable<String> _map_4 = IterableExtensions.<IU, String>map(importedIUs, _function_4);
    final Set<String> importedIUsID = IterableExtensions.<String>toSet(_map_4);
    EList<Location> _locations_1 = targetPlatform.getLocations();
    final Function1<Location, EList<IU>> _function_5 = new Function1<Location, EList<IU>>() {
      public EList<IU> apply(final Location it) {
        return it.getIus();
      }
    };
    List<EList<IU>> _map_5 = ListExtensions.<Location, EList<IU>>map(_locations_1, _function_5);
    Iterable<IU> _flatten_3 = Iterables.<IU>concat(_map_5);
    final Function1<IU, Boolean> _function_6 = new Function1<IU, Boolean>() {
      public Boolean apply(final IU it) {
        boolean _or = false;
        String _iD = it.getID();
        boolean _contains = importedIUsID.contains(_iD);
        if (_contains) {
          _or = true;
        } else {
          String _iD_1 = it.getID();
          int _count = localIUsID.count(_iD_1);
          boolean _greaterThan = (_count > 1);
          _or = _greaterThan;
        }
        return Boolean.valueOf(_or);
      }
    };
    Iterable<IU> _filter = IterableExtensions.<IU>filter(_flatten_3, _function_6);
    final Consumer<IU> _function_7 = new Consumer<IU>() {
      public void accept(final IU entry) {
        EList<Location> _locations = targetPlatform.getLocations();
        final Function1<Location, Boolean> _function = new Function1<Location, Boolean>() {
          public Boolean apply(final Location it) {
            EList<IU> _ius = it.getIus();
            final Function1<IU, String> _function = new Function1<IU, String>() {
              public String apply(final IU it) {
                return it.getID();
              }
            };
            List<String> _map = ListExtensions.<IU, String>map(_ius, _function);
            String _iD = entry.getID();
            return Boolean.valueOf(_map.contains(_iD));
          }
        };
        Iterable<Location> _filter = IterableExtensions.<Location>filter(_locations, _function);
        final Function1<Location, String> _function_1 = new Function1<Location, String>() {
          public String apply(final Location it) {
            return it.getUri();
          }
        };
        Iterable<String> _map = IterableExtensions.<Location, String>map(_filter, _function_1);
        final Set<String> localLocationsWithDup = IterableExtensions.<String>toSet(_map);
        final Function1<IU, Boolean> _function_2 = new Function1<IU, Boolean>() {
          public Boolean apply(final IU it) {
            String _iD = it.getID();
            String _iD_1 = entry.getID();
            return Boolean.valueOf(_iD.equals(_iD_1));
          }
        };
        Iterable<IU> _filter_1 = IterableExtensions.<IU>filter(importedIUs, _function_2);
        final Function1<IU, URI> _function_3 = new Function1<IU, URI>() {
          public URI apply(final IU it) {
            Resource _eResource = it.eResource();
            return _eResource.getURI();
          }
        };
        Iterable<URI> _map_1 = IterableExtensions.<IU, URI>map(_filter_1, _function_3);
        final Set<URI> importedTPsWithDup = IterableExtensions.<URI>toSet(_map_1);
        String _xifexpression = null;
        String _iD = entry.getID();
        boolean _contains = importedIUsID.contains(_iD);
        if (_contains) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("Duplicated IU \'");
          String _iD_1 = entry.getID();
          _builder.append(_iD_1, "");
          _builder.append("\' for locations \'");
          String _join = IterableExtensions.join(localLocationsWithDup, "\', \'");
          _builder.append(_join, "");
          _builder.append("\'. It is included from target platforms \'");
          String _join_1 = IterableExtensions.join(importedTPsWithDup, "\', \'");
          _builder.append(_join_1, "");
          _builder.append("\'.");
          _xifexpression = _builder.toString();
        } else {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Duplicated IU \'");
          String _iD_2 = entry.getID();
          _builder_1.append(_iD_2, "");
          _builder_1.append("\' for locations \'");
          String _join_2 = IterableExtensions.join(localLocationsWithDup, "\', \'");
          _builder_1.append(_join_2, "");
          _builder_1.append("\'.");
          _xifexpression = _builder_1.toString();
        }
        final String msg = _xifexpression;
        Location _location = entry.getLocation();
        Location _location_1 = entry.getLocation();
        EList<IU> _ius = _location_1.getIus();
        int _indexOf = _ius.indexOf(entry);
        TargetPlatformValidator.this.warning(msg, _location, TargetPlatformPackage.Literals.LOCATION__IUS, _indexOf, TargetPlatformValidator.CHECK__NO_DUPLICATED_IU);
      }
    };
    _filter.forEach(_function_7);
  }
}
